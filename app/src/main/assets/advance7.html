<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link type="text/css" href="style.css" rel="stylesheet"/>
</head>
<body>
<h1 style="text-align: center;">Python - Modules</h1>
<hr color="red">
<p>module allows you to logically organize your Python code. Grouping related code into a module makes the code easier to understand and use. A module is a Python object with arbitrarily named attributes that you can bind and reference.</p>
<p>Simply, a module is a file consisting of Python code. A module can define functions, classes and variables. A module can also include runnable code.</p>
<b>Example</b>
<p>The Python code for a module named aname normally resides in a file named aname.py. Here's an example of a simple module, support.py</p>
<pre>def print_func( par ):
    print "Hello : ", par
    return</pre>

<h3 style="color: hsl(120, 100%, 20%);">The import Statement</h3>
<p>You can use any Python source file as a module by executing an import statement in some other Python source file. The import has the following syntax −</p>
<pre>import module1[, module2[,... moduleN]</pre>
<p>When the interpreter encounters an import statement, it imports the module if the module is present in the search path. A search path is a list of directories that the interpreter searches before importing a module. For example, to import the module support.py, you need to put the following command at the top of the script −</p>
<pre>#!/usr/bin/python

    # Import module support
    import support

    # Now you can call defined function that module as follows
    support.print_func("Zara")</pre>
<p>When the above code is executed, it produces the following result −</p>
<pre>Hello : Zara</pre>
<p>A module is loaded only once, regardless of the number of times it is imported. This prevents the module execution from happening over and over again if multiple imports occur.</p>
<h3 style="color: hsl(120, 100%, 20%);">The from...import Statement</h3>
<p>Python's from statement lets you import specific attributes from a module into the current namespace. The from...import has the following syntax −</p>
<pre>from modname import name1[, name2[, ... nameN]]</pre>
<p>For example, to import the function fibonacci from the module fib, use the following statement −</p>
<pre>from fib import fibonacci</pre>
<p>This statement does not import the entire module fib into the current namespace; it just introduces the item fibonacci from the module fib into the global symbol table of the importing module.</p>
<h3 style="color: hsl(120, 100%, 20%);">The from...import* Statement</h3>
<p>It is also possible to import all names from a module into the current namespace by using the following import statement −</p>
<pre>from modname import *</pre>
<p>This provides an easy way to import all the items from a module into the current namespace; however, this statement should be used sparingly.</p>
<h3 style="color: hsl(120, 100%, 20%);">Locating Modules</h3>
<p>When you import a module, the Python interpreter searches for the module in the following sequences −</p>
<ul>
    <li>The current directory.</li>
    <li>If the module isn't found, Python then searches each directory in the shell variable PYTHONPATH.</li>
    <li>If all else fails, Python checks the default path. On UNIX, this default path is normally /usr/local/lib/python/.</li>
</ul>
<p>The module search path is stored in the system module sys as the sys.path variable. The sys.path variable contains the current directory, PYTHONPATH, and the installation-dependent default.</p>
<hr>
<h3 style="color: hsl(120, 100%, 20%);">The PYTHONPATH Variable</h3>
<p>The PYTHONPATH is an environment variable, consisting of a list of directories. The syntax of PYTHONPATH is the same as that of the shell variable PATH</p>
<p>Here is a typical PYTHONPATH from a Windows system −</p>
<pre>set PYTHONPATH = c:\python20\lib;</pre>
<p>And here is a typical PYTHONPATH from a UNIX system −</p>
<pre>set PYTHONPATH = /usr/local/lib/python</pre>
<hr>

<h3 style="color: hsl(120, 100%, 20%);">Namespaces and Scoping</h3>
<p>Variables are names (identifiers) that map to objects. A namespace is a dictionary of variable names (keys) and their corresponding objects (values).</p>
<p>A Python statement can access variables in a local namespace and in the global namespace. If a local and a global variable have the same name, the local variable shadows the global variable.</p>
<p>Each function has its own local namespace. Class methods follow the same scoping rule as ordinary functions.</p>
<p>Python makes educated guesses on whether variables are local or global. It assumes that any variable assigned a value in a function is local.</p>
<p>Therefore, in order to assign a value to a global variable within a function, you must first use the global statement.</p>
<p>The statement global VarName tells Python that VarName is a global variable. Python stops searching the local namespace for the variable.</p>
<p>For example, we define a variable Money in the global namespace. Within the function Money, we assign Money a value, therefore Python assumes Money as a local variable. However, we accessed the value of the local variable Money before setting it, so an UnboundLocalError is the result. Uncommenting the global statement fixes the problem</p>
<pre>#!/usr/bin/python

    Money = 2000
    def AddMoney():
       # Uncomment the following line to fix the code:
       # global Money
       Money = Money + 1

    print Money
    AddMoney()
    print Money</pre>









<br>
<br>
<a href="https://www.tutorialspoint.com/python/python_modules.htm#:~:text=A%20module%20is%20a%20Python,can%20also%20include%20runnable%20code."><input type=button value='Know More' style="color: white; background-color: green;height: 40px ; width: 100px;"></a>
<br>
<br>
<br>
<hr>
</body>
</html>